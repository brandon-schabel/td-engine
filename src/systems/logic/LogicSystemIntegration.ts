import type { Game } from '@/core/Game';
import type { GameContext, GameAction, InputState } from './types';
import { 
  updateEnemy, 
  updateTower, 
  updatePlayer, 
  updateProjectile,
  calculateDamage,
  generateCombatActions
} from './index';
import { Enemy } from '@/entities/Enemy';
import { Tower } from '@/entities/Tower';
import { Player } from '@/entities/Player';
import { Projectile } from '@/entities/Projectile';

/**
 * Example integration of logic systems into the game.
 * This shows how to use pure logic functions to update entities.
 */
export class LogicSystemIntegration {
  // State storage for entities (in a real implementation, this would be more sophisticated)
  private enemyStates = new Map<string, any>();
  private towerStates = new Map<string, any>();
  private playerState: any = {
    regenerationTimer: 0,
    damageCooldown: 0,
    healAbilityCooldown: 0,
    shootingCooldown: 0
  };
  private projectileStates = new Map<string, any>();

  /**
   * Update all game entities using logic systems
   */
  updateGameLogic(game: Game, deltaTime: number, inputState: InputState): void {
    // Create game context
    const context: GameContext = {
      deltaTime,
      enemies: game.getEnemies(),
      towers: game.getTowers(),
      player: game.getPlayer(),
      projectiles: game.getProjectiles(),
      grid: game.getGrid(),
      gameTime: Date.now(),
      isPaused: game.isPaused()
    };

    // Collect all actions from updates
    const allActions: GameAction[] = [];

    // Update enemies
    for (const enemy of context.enemies) {
      if (!enemy.isAlive) continue;

      const update = updateEnemy(enemy, context);
      
      // Apply updates to enemy
      if (update.position) {
        enemy.position = update.position;
      }
      if (update.velocity) {
        enemy.velocity = update.velocity;
      }
      if (update.targetId !== undefined) {
        // Update enemy's target based on logic
        this.updateEnemyTarget(enemy, update.targetId, context);
      }

      allActions.push(...update.actions);
    }

    // Update towers
    for (const tower of context.towers) {
      if (!tower.isAlive) continue;

      const update = updateTower(tower, context);
      
      // Apply updates to tower
      if (update.cooldown !== undefined) {
        tower.currentCooldown = update.cooldown;
      }

      allActions.push(...update.actions);
    }

    // Update player
    if (context.player) {
      const update = updatePlayer(
        context.player, 
        inputState, 
        context,
        this.playerState
      );
      
      // Apply updates to player
      if (update.position) {
        context.player.position = update.position;
      }
      if (update.velocity) {
        context.player.velocity = update.velocity;
      }
      if (update.cooldown !== undefined) {
        context.player.currentCooldown = update.cooldown;
      }

      allActions.push(...update.actions);
    }

    // Update projectiles
    for (const projectile of context.projectiles) {
      if (!projectile.isAlive) continue;

      const state = this.getProjectileState(projectile);
      const update = updateProjectile(projectile, context, state);
      
      // Apply updates to projectile
      if (update.position) {
        projectile.position = update.position;
      }
      if (update.velocity) {
        projectile.velocity = update.velocity;
      }
      if (update.isAlive !== undefined) {
        projectile.isAlive = update.isAlive;
      }

      allActions.push(...update.actions);
    }

    // Process all collected actions
    this.processGameActions(game, allActions);
  }

  /**
   * Process game actions generated by logic systems
   */
  private processGameActions(game: Game, actions: GameAction[]): void {
    for (const action of actions) {
      switch (action.type) {
        case 'SPAWN_PROJECTILE':
          this.spawnProjectile(game, action.projectile);
          break;
          
        case 'DAMAGE_ENTITY':
          this.damageEntity(game, action.targetId, action.damage, action.sourceId);
          break;
          
        case 'DESTROY_ENTITY':
          this.destroyEntity(game, action.entityId);
          break;
          
        case 'ADD_CURRENCY':
          game.addCurrency(action.amount);
          break;
          
        case 'SPAWN_COLLECTIBLE':
          game.spawnCollectible(action.position, action.collectibleType);
          break;
          
        case 'PLAY_SOUND':
          game.playSound(action.soundType, action.position);
          break;
          
        case 'CREATE_EFFECT':
          this.createEffect(game, action.effectType, action.position, action.data);
          break;
          
        case 'HEAL_ENTITY':
          this.healEntity(game, action.targetId, action.amount);
          break;
          
        case 'ADD_EXPERIENCE':
          if (game.getPlayer()) {
            game.getPlayer().addExperience(action.amount);
          }
          break;
      }
    }
  }

  private spawnProjectile(game: Game, data: any): void {
    const projectile = new Projectile(
      data.position,
      data.targetId ? this.findEntity(game, data.targetId) as Enemy : null,
      data.damage,
      data.speed,
      data.velocity,
      data.projectileType
    );
    
    game.addProjectile(projectile);
  }

  private damageEntity(game: Game, targetId: string, damage: number, sourceId?: string): void {
    const target = this.findEntity(game, targetId);
    if (!target) return;

    // Use combat logic for damage calculation
    const source = sourceId ? this.findEntity(game, sourceId) : null;
    const damageSource = {
      type: source instanceof Tower ? 'tower' : 
            source instanceof Player ? 'player' : 'projectile',
      damage,
      damageType: 'physical' as const,
      sourceId: sourceId || 'unknown'
    };

    const result = calculateDamage(damageSource, {
      id: target.id,
      health: target.health,
      maxHealth: target.maxHealth,
      armor: (target as any).armor || 0,
      magicResist: (target as any).magicResist || 0
    });

    // Apply damage
    target.takeDamage(result.finalDamage);

    // Generate combat effects
    const combatActions = generateCombatActions(
      result,
      sourceId || 'unknown',
      targetId,
      target.position
    );
    
    this.processGameActions(game, combatActions);
  }

  private healEntity(game: Game, targetId: string, amount: number): void {
    const target = this.findEntity(game, targetId);
    if (!target) return;

    target.heal(amount);
  }

  private destroyEntity(game: Game, entityId: string): void {
    const entity = this.findEntity(game, entityId);
    if (!entity) return;

    entity.isAlive = false;
  }

  private createEffect(game: Game, effectType: string, position: any, data?: any): void {
    // Create visual effects based on type
    // This would integrate with your effects system
    console.log(`Creating effect: ${effectType} at`, position, data);
  }

  private findEntity(game: Game, id: string): any {
    // Search all entity arrays for the given ID
    const allEntities = [
      ...game.getEnemies(),
      ...game.getTowers(),
      ...game.getProjectiles(),
      game.getPlayer()
    ].filter(Boolean);

    return allEntities.find(e => e.id === id);
  }

  private updateEnemyTarget(enemy: Enemy, targetId: string | null, context: GameContext): void {
    if (!targetId) {
      (enemy as any).target = null;
      return;
    }

    // Find target entity
    if (context.player && context.player.id === targetId) {
      (enemy as any).target = context.player;
    } else {
      const tower = context.towers.find(t => t.id === targetId);
      if (tower) {
        (enemy as any).target = tower;
      }
    }
  }

  private getProjectileState(projectile: Projectile): any {
    if (!this.projectileStates.has(projectile.id)) {
      this.projectileStates.set(projectile.id, {
        age: 0,
        hasHitTarget: false
      });
    }
    return this.projectileStates.get(projectile.id);
  }
}

// Example usage in Game class:
/*
class Game {
  private logicSystem = new LogicSystemIntegration();
  
  update(deltaTime: number): void {
    const inputState: InputState = {
      keys: this.inputManager.getPressedKeys(),
      mousePosition: this.inputManager.getMousePosition(),
      isMouseDown: this.inputManager.isMouseDown(),
      mobileInput: this.inputManager.getMobileInput()
    };
    
    // Update all game logic using pure functions
    this.logicSystem.updateGameLogic(this, deltaTime, inputState);
    
    // Continue with rendering, etc.
  }
}
*/